#include <stdio.h>
#define max 5
int enQueue(int *a,int front,int rear,int data){
    //循环队列中，如果尾指针和头指针重合，证明数组存放的数据已满
    if ((rear+1)%max==front) {
        printf("空间已满");
        return rear;
    }
    a[rear%max]=data;
    rear++;
    return rear;
}
int  deQueue(int *a,int front,int rear){
    //如果front==rear，表示队列为空
    if(front==rear) {
        printf("队列为空");
        return front;
    }
    printf("%d",a[front]);
    front=(front+1)%max;
    return front;
}
int main() {
    int a[max];
    int front,rear;
    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址
    front=rear=0;
    //入队
    rear=enQueue(a,front,rear, 1);
    rear=enQueue(a,front,rear, 2);
    rear=enQueue(a,front,rear, 3);
    rear=enQueue(a,front,rear, 4);
    //出队
    front=deQueue(a, front, rear);
   
    rear=enQueue(a,front,rear, 5);
   
    front=deQueue(a, front, rear);
    rear=enQueue(a,front,rear, 6);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    return 0;
}
运行结果：
123456

在使用循环队列判断数组是否已满时，出现下面情况：
当队列为空时，队列的头指针等于队列的尾指针
当数组满员时，队列的头指针等于队列的尾指针
要将空队列和队列满的情况区分开，办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了。

队列的链式表示和实现（简称为“链队列”）
队列的链式存储是在链表的基础上，按照“先进先出”的原则操作数据元素。

例如，将队列（1，2，3，4）依次入队，然后再依次出队。

代码实现：
纯文本复制
#include <stdio.h>
#include <stdlib.h>
typedef struct QNode{
    int data;
    struct QNode * next;
}QNode;
QNode * initQueue(){
    QNode * queue=(QNode*)malloc(sizeof(QNode));
    queue->next=NULL;
    return queue;
}
QNode* enQueue(QNode * rear,int data){
    QNode * enElem=(QNode*)malloc(sizeof(QNode));
    enElem->data=data;
    enElem->next=NULL;
    //使用尾插法向链队列中添加数据元素
    rear->next=enElem;
    rear=enElem;
    return rear;
}
void DeQueue(QNode * front,QNode * rear){
    if (front->next==NULL) {
        printf("队列为空");
        return ;
    }
    QNode * p=front->next;
    printf("%d",p->data);
    front->next=p->next;
    if (rear==p) {
        rear=front;
    }
    free(p);
}
int main() {
    QNode * queue,*front,*rear;
    queue=front=rear=initQueue();//创建头结点
    //向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素
    rear=enQueue(rear, 1);
    rear=enQueue(rear, 2);
    rear=enQueue(rear, 3);
    rear=enQueue(rear, 4);
    //入队完成，所有数据元素开始出队列
    DeQueue(front, rear);
    DeQueue(front, rear);
    DeQueue(front, rear);
    DeQueue(front, rear);
    DeQueue(front, rear);
    return 0;
}
